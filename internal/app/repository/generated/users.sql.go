// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package db

import (
	"context"
	"database/sql"
)

const createGoogleUser = `-- name: CreateGoogleUser :one
INSERT INTO users(auth_system,
                  sub,
                  name,
                  given_name,
                  family_name,
                  avatar,
                  email,
                  email_verified,
                  locale,
                  hashed_password,
                  role,
                  valid_till)
VALUES ('google',
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        'user',
        $10)
RETURNING id, auth_system, sub, name, given_name, family_name, avatar, email, email_verified, locale, hashed_password, role, valid_till
`

type CreateGoogleUserParams struct {
	Sub            sql.NullString `json:"sub"`
	Name           string         `json:"name"`
	GivenName      sql.NullString `json:"given_name"`
	FamilyName     sql.NullString `json:"family_name"`
	Avatar         sql.NullString `json:"avatar"`
	Email          string         `json:"email"`
	EmailVerified  bool           `json:"email_verified"`
	Locale         sql.NullString `json:"locale"`
	HashedPassword []byte         `json:"hashed_password"`
	ValidTill      sql.NullTime   `json:"valid_till"`
}

func (q *Queries) CreateGoogleUser(ctx context.Context, arg CreateGoogleUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createGoogleUser,
		arg.Sub,
		arg.Name,
		arg.GivenName,
		arg.FamilyName,
		arg.Avatar,
		arg.Email,
		arg.EmailVerified,
		arg.Locale,
		arg.HashedPassword,
		arg.ValidTill,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.AuthSystem,
		&i.Sub,
		&i.Name,
		&i.GivenName,
		&i.FamilyName,
		&i.Avatar,
		&i.Email,
		&i.EmailVerified,
		&i.Locale,
		&i.HashedPassword,
		&i.Role,
		&i.ValidTill,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users(auth_system,
                  name,
                  family_name,
                  given_name,
                  email,
                  email_verified,
                  hashed_password,
                  role,
                  valid_till)
VALUES ('direct',
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8)
RETURNING id, auth_system, sub, name, given_name, family_name, avatar, email, email_verified, locale, hashed_password, role, valid_till
`

type CreateUserParams struct {
	Name           string         `json:"name"`
	FamilyName     sql.NullString `json:"family_name"`
	GivenName      sql.NullString `json:"given_name"`
	Email          string         `json:"email"`
	EmailVerified  bool           `json:"email_verified"`
	HashedPassword []byte         `json:"hashed_password"`
	Role           string         `json:"role"`
	ValidTill      sql.NullTime   `json:"valid_till"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Name,
		arg.FamilyName,
		arg.GivenName,
		arg.Email,
		arg.EmailVerified,
		arg.HashedPassword,
		arg.Role,
		arg.ValidTill,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.AuthSystem,
		&i.Sub,
		&i.Name,
		&i.GivenName,
		&i.FamilyName,
		&i.Avatar,
		&i.Email,
		&i.EmailVerified,
		&i.Locale,
		&i.HashedPassword,
		&i.Role,
		&i.ValidTill,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const findUserById = `-- name: FindUserById :one
SELECT u.id,
       COALESCE(u.auth_system, '')     as auth_system,
       COALESCE(u.sub, '')             as sub,
       COALESCE(u.name, '')            as name,
       COALESCE(u.given_name, '')      as given_name,
       COALESCE(u.family_name, '')     as family_name,
       COALESCE(u.avatar, '')          as avatar,
       COALESCE(u.email, '')           as email,
       u.email_verified,
       COALESCE(u.locale, '')          as locale,
       COALESCE(u.hashed_password, '') as hashed_password,
       COALESCE(u.role, '')            as role
FROM users u
WHERE u.id = $1
`

type FindUserByIdRow struct {
	ID             int64  `json:"id"`
	AuthSystem     string `json:"auth_system"`
	Sub            string `json:"sub"`
	Name           string `json:"name"`
	GivenName      string `json:"given_name"`
	FamilyName     string `json:"family_name"`
	Avatar         string `json:"avatar"`
	Email          string `json:"email"`
	EmailVerified  bool   `json:"email_verified"`
	Locale         string `json:"locale"`
	HashedPassword []byte `json:"hashed_password"`
	Role           string `json:"role"`
}

func (q *Queries) FindUserById(ctx context.Context, id int64) (FindUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, findUserById, id)
	var i FindUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.AuthSystem,
		&i.Sub,
		&i.Name,
		&i.GivenName,
		&i.FamilyName,
		&i.Avatar,
		&i.Email,
		&i.EmailVerified,
		&i.Locale,
		&i.HashedPassword,
		&i.Role,
	)
	return i, err
}

const findUserByLogin = `-- name: FindUserByLogin :one
SELECT u.id,
       COALESCE(u.auth_system, '')     as auth_system,
       COALESCE(u.sub, '')             as sub,
       COALESCE(u.name, '')            as name,
       COALESCE(u.given_name, '')      as given_name,
       COALESCE(u.family_name, '')     as family_name,
       COALESCE(u.avatar, '')          as avatar,
       COALESCE(u.email, '')           as email,
       u.email_verified,
       COALESCE(u.locale, '')          as locale,
       COALESCE(u.hashed_password, '') as hashed_password,
       COALESCE(u.role, '')            as role
FROM users u
WHERE u.email = $1
`

type FindUserByLoginRow struct {
	ID             int64  `json:"id"`
	AuthSystem     string `json:"auth_system"`
	Sub            string `json:"sub"`
	Name           string `json:"name"`
	GivenName      string `json:"given_name"`
	FamilyName     string `json:"family_name"`
	Avatar         string `json:"avatar"`
	Email          string `json:"email"`
	EmailVerified  bool   `json:"email_verified"`
	Locale         string `json:"locale"`
	HashedPassword []byte `json:"hashed_password"`
	Role           string `json:"role"`
}

func (q *Queries) FindUserByLogin(ctx context.Context, email string) (FindUserByLoginRow, error) {
	row := q.db.QueryRowContext(ctx, findUserByLogin, email)
	var i FindUserByLoginRow
	err := row.Scan(
		&i.ID,
		&i.AuthSystem,
		&i.Sub,
		&i.Name,
		&i.GivenName,
		&i.FamilyName,
		&i.Avatar,
		&i.Email,
		&i.EmailVerified,
		&i.Locale,
		&i.HashedPassword,
		&i.Role,
	)
	return i, err
}

const findUserByLoginAndSystem = `-- name: FindUserByLoginAndSystem :one
SELECT u.id,
       COALESCE(u.auth_system, '')     as auth_system,
       COALESCE(u.sub, '')             as sub,
       COALESCE(u.name, '')            as name,
       COALESCE(u.given_name, '')      as given_name,
       COALESCE(u.family_name, '')     as family_name,
       COALESCE(u.avatar, '')          as avatar,
       COALESCE(u.email, '')           as email,
       u.email_verified,
       COALESCE(u.locale, '')          as locale,
       COALESCE(u.hashed_password, '') as hashed_password,
       COALESCE(u.role, '')            as role
FROM users u
WHERE u.email = $1
  AND u.auth_system = $2
`

type FindUserByLoginAndSystemParams struct {
	Email      string         `json:"email"`
	AuthSystem sql.NullString `json:"auth_system"`
}

type FindUserByLoginAndSystemRow struct {
	ID             int64  `json:"id"`
	AuthSystem     string `json:"auth_system"`
	Sub            string `json:"sub"`
	Name           string `json:"name"`
	GivenName      string `json:"given_name"`
	FamilyName     string `json:"family_name"`
	Avatar         string `json:"avatar"`
	Email          string `json:"email"`
	EmailVerified  bool   `json:"email_verified"`
	Locale         string `json:"locale"`
	HashedPassword []byte `json:"hashed_password"`
	Role           string `json:"role"`
}

func (q *Queries) FindUserByLoginAndSystem(ctx context.Context, arg FindUserByLoginAndSystemParams) (FindUserByLoginAndSystemRow, error) {
	row := q.db.QueryRowContext(ctx, findUserByLoginAndSystem, arg.Email, arg.AuthSystem)
	var i FindUserByLoginAndSystemRow
	err := row.Scan(
		&i.ID,
		&i.AuthSystem,
		&i.Sub,
		&i.Name,
		&i.GivenName,
		&i.FamilyName,
		&i.Avatar,
		&i.Email,
		&i.EmailVerified,
		&i.Locale,
		&i.HashedPassword,
		&i.Role,
	)
	return i, err
}

const findUserBySub = `-- name: FindUserBySub :one
SELECT id,
       coalesce(sub, '')    as sub,
       name,
       given_name,
       family_name,
       coalesce(avatar, '') as avatar,
       email,
       email_verified,
       coalesce(locale, '') as locale,
       hashed_password,
       role
FROM users u
WHERE u.sub = $1
`

type FindUserBySubRow struct {
	ID             int64          `json:"id"`
	Sub            string         `json:"sub"`
	Name           string         `json:"name"`
	GivenName      sql.NullString `json:"given_name"`
	FamilyName     sql.NullString `json:"family_name"`
	Avatar         string         `json:"avatar"`
	Email          string         `json:"email"`
	EmailVerified  bool           `json:"email_verified"`
	Locale         string         `json:"locale"`
	HashedPassword []byte         `json:"hashed_password"`
	Role           string         `json:"role"`
}

func (q *Queries) FindUserBySub(ctx context.Context, sub sql.NullString) (FindUserBySubRow, error) {
	row := q.db.QueryRowContext(ctx, findUserBySub, sub)
	var i FindUserBySubRow
	err := row.Scan(
		&i.ID,
		&i.Sub,
		&i.Name,
		&i.GivenName,
		&i.FamilyName,
		&i.Avatar,
		&i.Email,
		&i.EmailVerified,
		&i.Locale,
		&i.HashedPassword,
		&i.Role,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id,
       coalesce(auth_system, '') as auth_system,
       coalesce(sub, '')         as sub,
       name,
       given_name,
       family_name,
       coalesce(avatar, '')      as avatar,
       email,
       email_verified,
       coalesce(locale, '')      as locale,
       hashed_password,
       role
FROM users
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListUsersRow struct {
	ID             int64          `json:"id"`
	AuthSystem     string         `json:"auth_system"`
	Sub            string         `json:"sub"`
	Name           string         `json:"name"`
	GivenName      sql.NullString `json:"given_name"`
	FamilyName     sql.NullString `json:"family_name"`
	Avatar         string         `json:"avatar"`
	Email          string         `json:"email"`
	EmailVerified  bool           `json:"email_verified"`
	Locale         string         `json:"locale"`
	HashedPassword []byte         `json:"hashed_password"`
	Role           string         `json:"role"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthSystem,
			&i.Sub,
			&i.Name,
			&i.GivenName,
			&i.FamilyName,
			&i.Avatar,
			&i.Email,
			&i.EmailVerified,
			&i.Locale,
			&i.HashedPassword,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET auth_system     = $2,
    sub             = $3,
    name            = $4,
    given_name      = $5,
    family_name     = $6,
    avatar          = $7,
    email           = $8,
    email_verified  = $9,
    locale          = $10,
    hashed_password = $11,
    role            = $12,
    valid_till      = $13
WHERE id = $1
`

type UpdateUserParams struct {
	ID             int64          `json:"id"`
	AuthSystem     sql.NullString `json:"auth_system"`
	Sub            sql.NullString `json:"sub"`
	Name           string         `json:"name"`
	GivenName      sql.NullString `json:"given_name"`
	FamilyName     sql.NullString `json:"family_name"`
	Avatar         sql.NullString `json:"avatar"`
	Email          string         `json:"email"`
	EmailVerified  bool           `json:"email_verified"`
	Locale         sql.NullString `json:"locale"`
	HashedPassword []byte         `json:"hashed_password"`
	Role           string         `json:"role"`
	ValidTill      sql.NullTime   `json:"valid_till"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.ID,
		arg.AuthSystem,
		arg.Sub,
		arg.Name,
		arg.GivenName,
		arg.FamilyName,
		arg.Avatar,
		arg.Email,
		arg.EmailVerified,
		arg.Locale,
		arg.HashedPassword,
		arg.Role,
		arg.ValidTill,
	)
	return err
}
